{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Internal documentation for the ASBD project and all neighboring projects.</p>"},{"location":"misc/inline-menu-items/","title":"Inline Menu Items","text":"<p>An inline menu is a colection of links, typically renered as icon buttons. These can be found in pretty much every listing page throughout the application.</p> <p>As of the time of writing this (September 2024), the <code>inline_menu_item.py</code> defines the following three template tags:</p> <code>inline_menu_icon</code> Links rendered as icons <code>inline_menu_item</code> Links rendered as normal links. Deprecated <code>inline_menu_item_new</code> A replacement of the deprecated <code>inline_menu_item</code>"},{"location":"misc/inline-menu-items/#inline-menu-icon","title":"Inline Menu Icon","text":"<p>The most widely used tag for inline menu items. The link is rendered as an icon for a better UX experience.</p> <p>Every object, with exceptions of course, has a detail, update and delete views associated with them. For that reason there are usually three icons (inline menu items) for each object in a listing page (as can be observed on the image below).</p> <p></p> Function signature<pre><code>def inline_menu_icon(icon_type, url_address, tooltip=None, **kwargs):\n    ...\n</code></pre> <p>The only mandatory parameters are the <code>url_address</code> and <code>icon_type</code>.</p> <code>url_address</code> <p>A reversible view name.</p> <p>As the function accepts kwargs, query parameters can be passed in as regular kwargs (i.e. <code>query_param=value</code>).</p> <p>As for path parameters, they just need a prefix of <code>get_</code> (i.e. <code>get_path_param=value</code>).</p> <code>icon_type</code> The type of icon to render. Right now, there is no way to define a custom icon while defining the menu item, only the icons in the following table are supported. If an unsupported icon is passed in, the default icon is rendered instead. Icon Name Bootstrap Icon Class Color Label detail <code>bi bi-info-lg</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_normal']</code> Detail create <code>bi bi-folder-plus</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> Vytvo\u0159it update <code>bi bi-pencil-square</code> <code>text-info</code> Upravit delete <code>bi bi-trash-fill</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_danger']</code> Vymazat disconnect <code>bi bi-ban</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_danger']</code> Odpojit copy <code>bi bi-journals</code> <code>text-warning</code> Kop\u00edrovat paste <code>bi bi-clipboard2-check-fill</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> Vlo\u017eit activate <code>bi bi-play-circle-fill</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> Aktivovat connect <code>bi bi-paperclip</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> P\u0159ipojit range <code>bi bi-arrows-expand-vertical</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> Rozsah default <code>bi bi-question-circle-fill</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_danger']</code> Invalid icon add <code>bi bi-plus-circle</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_normal']</code> P\u0159idat configuration <code>bi bi-gear</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_success']</code> Konfigurace competency <code>bi bi-key</code> <code>DEFAULT_APPLICATION_BUTTONS_LINKS_CONFIGURATION['link_color_danger']</code> Opr\u00e1vn\u011bn\u00ed <code>tooltip</code> An optional tooltip that is shown when the user hovers over the icon. If no tooltip is defined, the label from the table above is used as the tooltip. Examples<pre><code># Blue update icon (bi bi-pencil-square) with the link /accounts/createconfiguration/?user_id=16\n{% inline_menu_icon 'update' 'accounts:account-configuration-create' user_id=requested_user.pk %}\n\n# Blue update icon (bi bi-pencil-square) with the link /accounts/editprofile/16/ \n{% inline_menu_icon 'update' 'accounts:account-edit-profile' get_pk=requested_user.pk %}\n\n\n# Dark blue detail icon (bi bi-info-lg) with the link /najemnijednotky/bytydetail/1/ \n{% inline_menu_icon 'detail' 'byty:najemnici-detail' get_pk=each.id %}\n\n# Blue update icon (bi bi-pencil-square) with the link /najemnijednotky/bytyupdate/1/?sourcecaller=L&amp;referraldumid=1\n{% inline_menu_icon 'update' 'byty:najemnici-update' get_pk=each.id sourcecaller='L' referraldumid=referral_dum.pk %}\n\n# Red delete icon (bi bi-trash-fill) with the link /najemnijednotky/bytydelete/1/?sourcecaller=L&amp;referraldumid=1\n{% inline_menu_icon 'delete' 'byty:najemnici-delete' 'Odpojit' get_pk=each.id sourcecaller='L' referraldumid=referral_dum.pk %}\n</code></pre>"},{"location":"misc/inline-menu-items/#inline-menu-item","title":"Inline Menu Item","text":"<p>Inline menu items differ from their icon counterpart only in the way they are presented to the user, not as icons but as regular links (as can be seen on the image below).</p> <p></p> Function signature<pre><code>def inline_menu_item_new(link_text, url_address, style=None, **kwargs):\n    ...\n</code></pre> <p>The only mandatory parameters are the <code>link_text</code> and <code>url_address</code>.</p> <code>link_text</code> The label of the link. <code>url_address</code> <p>A reversible view name.</p> <p>As the function accepts kwargs, query parameters can be passed in as regular kwargs (i.e. <code>query_param=value</code>).</p> <p>As for path parameters, they just need a prefix of <code>get_</code> (i.e. <code>get_path_param=value</code>).</p> <code>style</code> <p>An optional list of classes.</p> <p>Might be replaced for a <code>StyleModifier</code> in the future.</p> Examples<pre><code># Link with the label depending on the value of \"each.byt_id.variabilni\" and link /najemnijednotky/pocetosoblist/?referralbytid=1\n{% inline_menu_item_new each.byt_id.variabilni 'byty:pocetosob-listing' referralbytid=each.byt_id.pk %}\n\n# Link with the label depending on the value of \"each.sluzba.just_name\" and link /sluzby/sluzbydefinicedetail/2/\n{% inline_menu_item_new each.sluzba.just_name 'sluzby:sluzbydefinice-detail' get_pk=each.sluzba.pk %}\n</code></pre>"},{"location":"misc/utility-mixins/","title":"Utility Mixins","text":""},{"location":"misc/utility-mixins/#hotkey-mixin","title":"Hotkey Mixin","text":"<p>The <code>HotkeyMixin</code> allows us to use keyboard shortcuts in the browser using JavaScript. On the backend, we define what shortcuts do what actions and that information is handed of to the JavaScript on the frontend which takes care of detecting occurances and performing the predefined actions.</p> <p>Currently, a keyboard shortcut can either perform a redirection or run a piece of JavaScript code.</p> <p>The <code>HotkeyMixin</code> defines a singular property:</p> <code>hotkeys_enabled</code> <p>Allows us to enable/disable the hotkey funcionality.</p> <p>Defaults to <code>True</code>.</p>"},{"location":"misc/utility-mixins/#usage","title":"Usage","text":"<p>First, we need to extend our view with the <code>HotkeyMixin</code> class and provide our hotkeys by overriding the <code>get_hotkeys()</code> function. The original implementaion returns an empty list so not overriding it will not raise any exceptions.</p> <p>The <code>get_hotkeys()</code> function needs to return a list of <code>Hotkey</code> instances. The <code>Hotkey</code> class itself is abstract so it's children must be used.</p> <p>The key combinations are represented as tuples of individual keys.</p> Example key combination constant<pre><code>KATEGORIEZALOHY_LISTING_ADD_NEW_HOT_KEY = ('CTRL', 'ALT', 'N')\n</code></pre> <pre><code>class MyView(HotkeyMixin):\n    def get_hotkeys(self):\n        return [\n            RedirectHotkey(('ALT', 'P'), reverse('app:view_name'))\n        ]\n</code></pre>"},{"location":"misc/utility-mixins/#creating-custom-hotkey-classes","title":"Creating custom hotkey classes","text":"<p>The base <code>Hotkey</code> class is abstract so it cannot be used on its own.</p> <p>The constructor only accepts the key combination as a tuple.</p> <p>Avery class extending the base <code>Hotkey</code> class must implement the <code>serialize()</code> function which will be unique to every type of hotkey.</p> The base class implementation<pre><code>class Hotkey(ABC):\n    def __init__(self, combination: tuple) -&gt; None:\n        self.combination = combination\n\n    @property\n    def serialized_combination(self) -&gt; str:\n        return '+'.join(self.combination)\n\n    @abstractmethod\n    def serialize(self) -&gt; tuple:\n        pass\n</code></pre> <p>The most commonly used hotkey is the <code>RedirectHotkey</code> which upon triggering simply redirects the user to a predefined page.</p> <p>We can see that the constructor now also accepts a link alongside the combination.</p> <p>The implementation of the <code>serialize()</code> function returns a tuple containing the serialized key combination and a dictionary that is specifically structured so the JavaScript on the other side knows what to do with it.</p> RedirectHotkey class implementation<pre><code>class RedirectHotkey(Hotkey):\n    def __init__(self, combination: tuple, link: str) -&gt; None:\n        super().__init__(combination)\n        self.link = link\n\n    def serialize(self) -&gt; tuple:\n        return self.serialized_combination, {'link': self.link}\n</code></pre>"},{"location":"misc/utility-mixins/#auto-refresh-mixin","title":"Auto Refresh Mixin","text":"<p>If we have a page that needs to be refreshed constantly so the the data is also refreshed this mixin can be uitlized to achieve that goal.</p> <p>The <code>AutoRefreshMixin</code> defines three properties:</p> <code>refresh_enabled</code> <p>Can be used to control if the page will periodically refresh or not - we can dynamically set when to use the mixin and when to not.   </p> <p>Defaults to <code>True</code>.</p> <code>refresh_period</code> <p>This property must be set or <code>ImproperlyConfigured</code> exception is raised.</p> Configuring the refresh period<pre><code>class MyView(AutoRefreshMixin):\n    refresh_period = 1000\n\n# or\n\nclass MyView(AutoRefreshMixin):\n    def get_period(self):\n        return 1000\n</code></pre> <code>max_refresh_cycles</code> <p>Defines if there is a limit to how many times we can refresh the page.</p> <p>The cycle count is stored in session storage of the browser.</p> <p>Defaults to <code>-1</code>.</p>"},{"location":"misc/utility-mixins/#delayed-redirect-mixin","title":"Delayed Redirect Mixin","text":"<p>If we need the user to be redirected somewhere after loading a page, we can use the <code>DelayedRedirectMixin</code>.</p> <p>For example, after a user logged in, we display a welcome page and after 5 seconds we redirect them somewhere (anywhere, doesn't matter).</p> <p>The <code>AutoRefreshMixin</code> defines three properties:</p> <code>redirect_enabled</code> <p>Can be used to control if the page will perform the redirect after the configured period - we can dynamically set when to use the mixin and when to not.   </p> <p>Defaults to <code>True</code>.</p> <code>redirect_link</code> <p>This property must be set or <code>ImproperlyConfigured</code> exception is raised.</p> <p>The link to redirect the user to after a given period after loding the page.</p> <code>redirect_delay</code> <p>This property must be set or <code>ImproperlyConfigured</code> exception is raised.</p> <p>How long to wait before performing the redirection.</p> Usage<pre><code>class MyView(DelayedRedirectMixin):\n    redirect_delay = 5000\n    redirect_link = reverse_lazy('app:view_name')\n\n# or\n\nclass MyView(DelayedRedirectMixin):\n    def get_redirect_to(self):\n        return reverse('app:view_name')\n\n    def get_delay(self):\n        return 5000\n</code></pre>"},{"location":"misc/view-template-configuration/","title":"ViewTemplateConfiguration","text":""},{"location":"misc/view-template-configuration/#the-idea","title":"The idea","text":"<p>The idea behind the <code>DatabaseConfigurableTemplateMixin</code> is to have an option to modify the context, class parameters and then some for a given view directly from the database.</p> <p>Views that extend the <code>DjangoPuzzleMixinWrapper</code> already extend the <code>DatabaseConfigurableTemplateMixin</code> as so all the developer needs is assign an id to the view like so:</p> <pre><code>class MyView(DatabaseConfigurableTemplateMixin):\n    view_id = 'my-class' # 30chars length restriction\n</code></pre>"},{"location":"misc/view-template-configuration/#the-model","title":"The model","text":"<p>The configuration for each view is stored in the database using the following <code>ViewTemplateConfiguration</code> view.</p> <pre><code>class ViewTemplateConfiguration(models.Model):\n    # Display name for easier orientation\n    view_name = models.CharField(max_length=50)\n    # View ID - serves as some kind of \"ForeignKey\" to connect View with its DB configuration\n    view_id = models.CharField(max_length=30)\n    # Template name\n    template_name = models.CharField(max_length=150, null=True, blank=True)\n    # This dictionary is added as is into View.other_context parameter_name (append operation)\n    extra_context = models.JSONField(default=dict, null=True, blank=True)\n    # Attributes used inside of View class instance as its own class-&gt;parameter_name.paramXYname\n    # used in behaviour modification for example\n    extra_parameters = models.JSONField(default=dict, null=True, blank=True)\n</code></pre> <p>As we can see, we can alter the view's context, class parameters and the template.</p>"},{"location":"misc/view-template-configuration/#front-end","title":"Front-end","text":"<p>The database record can of course be manually modified from the admin interface. Occasionally though, the users themselves need to be able to modify a view's context for whatever reason. This is where the context configuration view comes in.</p> <p>The configuration view can be accessed at <code>/common/configure-view/</code>. It expects an app name and a view name separated by a colon (:) - the same the <code>reverse()</code> function is used (i.e. <code>reverse('app:view_name')</code>).</p> <p>Accessing a configuration view</p> <p>We have a view defined in <code>urls.py</code> like so: urls.py<pre><code>app_name = 'byty'\npath('sestavabytyvlastnici/', SestavaBytyVlastnici.as_view(), name='sestava-byty-vlastnici')\n</code></pre> The URL to the configuration view for this particular view will be <code>/common/configure-view/byty:sestava-byty-vlastnici'</code>.</p>"},{"location":"misc/view-template-configuration/#requirements","title":"Requirements","text":"<p>In order for a view to take advantage of the configuration view it has to conform to the \"standard\".</p> <ul> <li>The view must extend the <code>DatabaseConfigurableTemplateMixin</code></li> <li>A <code>view_id</code> property must be specified (so the view can be linked to a database record)</li> <li>A <code>user_configurables</code> property must be specified (so the view knows which parameters to make available for users to modify)</li> </ul>"},{"location":"misc/view-template-configuration/#user-configurables","title":"User configurables","text":"<p>We might not want to give acccess to all the view parameters but just a subset, that's where the <code>user_configurables</code> property comes in.</p> <pre><code>class MyView(DatabaseConfigurableTemplateMixin):\n    view_id = 'my_view'\n    user_configurables = {\n        'extra_context': [\n            {\n                'name': 'context1',\n                'label': 'Context parameter 1',\n                'placeholder': 'e.g. 123'\n            }\n        ],\n        'extra_parameters': [\n            {\n                'name': 'param1',\n                'label': 'Class parameter 1',\n                'placeholder': 'e.g. 123'\n            }\n        ]\n    }\n</code></pre> <p>This dictionary pretty much describes what the configuration form will look like (as per the following image). </p> <p></p> <p>Note that the <code>name</code> values will be used as keys in the database - a context parameter defined here will be available in the global context in a template under the same name.</p>"},{"location":"misc/view-template-configuration/#tags","title":"Tags","text":"<p>An optional feature of the configuration front-end is the tags system. A list of tags can be added into the <code>user_configurables</code> dictionary like so:</p> <pre><code>user_configurables = {\n    'tags': ['report'],\n    \"extra_context\": [\n        {\n            'name': 'contact_email',\n            'label': 'Kontaktn\u00ed e-mail',\n            'placeholder': 'Nap\u0159. info@asbd.cz',\n        }\n    ]\n}\n</code></pre> <p>When navigating to <code>/common/configure-view</code>, links to all configurable views are displayed. If we add a <code>?tags</code> query parameter into the URL, we can direct which links are displayed.</p> <p>The usage of tags</p> <p>We have defined in our <code>user_configurables</code> the following tags - report, ucetni. If we navigate to <code>/common/configure-view/?tags=report</code>, only views tagged with the <code>report</code> tag are displayed. If no tags are defined in the url, all views are displayed.</p>"},{"location":"reports/","title":"Reports","text":"<p>A report is a document meant to be exported (usually to PDF). It is pretty much just a collection of tables with some other content if needed.</p>"},{"location":"reports/building-blocks/","title":"Building blocks","text":"<p>All tables are constructed from several basic building blocks that are comprehensively described in the following sections.</p>"},{"location":"reports/building-blocks/#reporttablecell","title":"ReportTableCell","text":"<p>The cell is the smallest building block within a table. It has two main properties:</p> <pre><code>def __init__(self, value=None, default_value='-', custom_css=None) -&gt; None:\n    ...\n</code></pre> <code>value</code> <p>Value to be rendered inside of the cell</p> <p>Defaults to <code>None</code>.</p> <code>default_value</code> <p>Gets rendered inside of the cell if the <code>value</code> is Falsy (None or an empty string)</p> <p>Defaults to '-' (a dash).</p> <p>Accepts a <code>StyleModifier</code>.</p> <p>The <code>ReportTableCell</code> class can be extended to allow for creation of custom cells, which increases efficiency.</p>"},{"location":"reports/building-blocks/#emptycell","title":"EmptyCell","text":"<p>Simply a cell with no value.</p> <p>A <code>ReportTableCell</code> with both <code>value</code> and <code>default_value</code> set to an empty string.</p> <pre><code>ReportTableCell(default_value='')\n# vs\nEmptyCell()\n</code></pre>"},{"location":"reports/building-blocks/#booleancell","title":"BooleanCell","text":"<p>Expects a boolean value.</p> <p>Based on the <code>true</code> and <code>false</code> arguments, the boolean value is translated.</p> <pre><code>def __init__(self, value, true='ANO', false='NE', default_value='-', custom_css=None) -&gt; None:\n    ... \n</code></pre> <p>The default translation:</p> Value Translation True Ano False Ne <pre><code>ReportTableCell('Ano' if True else 'Ne')\n# vs\nBooleanCell(True) # -&gt; Ano\nBooleanCell(True, true='Yes') # -&gt; Yes\n</code></pre>"},{"location":"reports/building-blocks/#datecell","title":"DateCell","text":"<p>Expects a value of type <code>datetime.date</code>.</p> <p>Formats the date to a specified format.</p> <pre><code>def __init__(self, value, _format='%d.%m.%Y', default_value='-', custom_css=None) -&gt; None:\n    ...\n</code></pre> <p>The date format defaults to '%d.%m.%Y'.</p> <pre><code>ReportTableCell(datetime.date(1, 1, 2024).strftime('%d.%m.%Y'))\n# vs\nDateCell(datetime.date(1, 1, 2024)) # -&gt; 1.1.2024\nDateCell(datetime.date(1, 1, 2024), _format='%d/%m/%Y') # -&gt; 1/1/2024\n</code></pre>"},{"location":"reports/building-blocks/#choicecell","title":"ChoiceCell","text":"<p>Best demonstrated with an example.</p> <pre><code>typy_jednotek = (\n    ('A', 'Bytov\u00e1 jednotka'),\n    ('B', 'N\u00e1jemn\u00ed prostor'),\n)\n\nReportTableCell(dict(typy_jednotek).get('A'))\n# vs\nChoiceCell('A', typy_jednotek) # -&gt; Bytov\u00e1 jednotka\n</code></pre>"},{"location":"reports/building-blocks/#currencycell","title":"CurrencyCell","text":"<p>Expects a <code>float</code> or a list of <code>float</code>s.</p> <p>Text within these cells is aligned to the right.</p> <pre><code>ReportTableCell('69 420,00 K\u010d')\n# vs\nCurrencyCell(69420) # -&gt; 69 420,00 K\u010d\n</code></pre> Prefix and suffix<pre><code>CurrencyCell(1000, prefix='(-)') # -&gt; (-) 1 000,00 K\u010d\nCurrencyCell(1000, suffix=' (+)') # -&gt; 1 000,00 K\u010d (+)\nCurrencyCell(1000, prefix='(-)', suffix=' (+)') # -&gt; (-) 1 000,00 K\u010d (+)\n</code></pre> <p>Under the hood, Babel is used for formatting. The function call to <code>format_currency()</code> used by <code>CurrencyCell</code> can be seen below.</p> Format call to Babel<pre><code>babel.numbers.format_currency(value, \"CZK\", format=u\"#,##0.00 \u00a4\", locale=\"cs_CZ\")\n</code></pre>"},{"location":"reports/building-blocks/#numbercell","title":"NumberCell","text":"<p>Expects a number.</p> <p>A custom format can be passed in using <code>custom_format</code>.</p> <p>The Babel library is used for formatting. More on formatting string here.</p> <pre><code>ReportTableCell('42.000')\n# vs\nNumberCell(42, custom_format='#,##0.000') # -&gt; 42.000\n</code></pre>"},{"location":"reports/building-blocks/#reporttablerow","title":"ReportTableRow","text":"<p>A row is just a collection of cells.</p> <p>Similarly as <code>ReportTableCell</code>, it accepts a <code>StyleModifier</code>.</p> <pre><code>def __init__(self, cells, custom_css=None) -&gt; None:\n    ...\n</code></pre> <pre><code>ReportTableRow((\n    ReportTableCell('1'),\n    ReportTableCell('2'),\n    ReportTableCell('3')\n))\n</code></pre>"},{"location":"reports/building-blocks/#reporttable","title":"ReportTable","text":"<p>At last, we arrive at the top level building block - the <code>ReportTable</code>. Every table in a report corresponds to an instance of this class.</p> <pre><code>def __init__(self, columns: Iterable[str | ReportTableCell] = None,\n                heading: str = None, info: str = None,\n                extra_data: dict = None,\n                custom_css: StyleModifier = None) -&gt; None:\n    self.custom_css = custom_css or StyleModifier()\n    if columns:\n        self.columns = tuple(\n            map(lambda column: column if isinstance(column, ReportTableCell) else ReportTableCell(column),\n                columns))\n    self.heading = heading\n    self.extra_data = {} if extra_data is None else extra_data\n    self.info = info\n    self.rows = []\n    self.translations = {}\n</code></pre> <p>The class properties are the following:</p> <code>heading</code> <p>An optional heading text.</p> <p>By default rendered right above the table.</p> <code>info</code> <p>An optional info text.</p> <p>By default rendered below the heading.</p> <code>columns</code> <p>A collection column cells.</p> <p>Can be a mix of strings and instances of <code>ReportTableCell</code> (e.g. if custom CSS is necessary).</p> <p>If left empty, the table becomes headless.</p> <code>rows</code> <p>A collection of actual table rows (excluding the first row - the &lt;thead&gt;).</p> <p>Rows are added using dedicated methods, cannot be passed into to the constructor.</p> <code>extra_data</code> <p>An optional dictionary can be bound to a table and later accessed in the template for more complex rendering.</p> <code>translations</code> <p>Optional mapping dictionary for translating values in cells.</p> <pre><code>ReportTable(('column 1', 'column 2'), 'heading', 'info text', {'key':'val'})\n</code></pre> <p>There are two ways of adding rows to tables - explicit and implicit.</p> Explicit function<pre><code>table = ReportTable()\n# Takes in a row object\ntable.add_row_expl(ReportTableRow.of(\n    ReportTableCell(),\n    ...\n))\n</code></pre> Implicit function<pre><code>table = ReportTable()\n# Takes in an arbitrary amount of cell objects\ntable.add_row_impl(\n    ReportTableCell(),\n    ...\n)\n</code></pre>"},{"location":"reports/building-blocks/#headlessreporttable","title":"HeadlessReportTable","text":"<p>A headless table is simply put a table without a header row (without the &lt;th&gt; tag).</p> <pre><code># We have to specify an empty tuple for the columns\nReportTable((), heading=\"Headless table\")\n# vs\n# Implicit empty columns tuple\nHeadlessReportTable(heading=\"Headless table\")\n</code></pre>"},{"location":"reports/building-blocks/#dictionaryreporttable","title":"DictionaryReportTable","text":"<p>A dictionary report table is meant to consume a dictionary and render as a two-column table. The column names have to be provided.</p> <pre><code>DictionaryReportTable(('Column 1', 'Column 2'), {})\n# or\nDictionaryReportTable(('Column 1', 'Column 2')).dictionary({})\n</code></pre>"},{"location":"reports/building-blocks/#headlessdictionaryreporttable","title":"HeadlessDictionaryReportTable","text":"<p>This table is derived from both the <code>HeadlessReportTable</code> and <code>DictionaryReportTable</code>. It renders as a table with two columns without a head row at the top of the table.</p> <pre><code>HeadlessDictionaryReportTable({})\n</code></pre>"},{"location":"reports/building-reports/","title":"Building a Report","text":"<p>A report is just like any other view in Django. We understandably have to use CBV as the whole report system is built with the approach in mind.</p> <p>First things first, let's create our view and extend the <code>ReportView</code> class.</p> Create view<pre><code>class MyReportView(ReportView):\n    pass\n</code></pre> <p>When we open our view we get an <code>ImproperlyConfigured</code> exception saying ReportMixin requires either a definition of 'report_headline' or an implementation of 'get_report_headline()'. So we have to define our report headline.</p> Define headline<pre><code>class MyReportView(ReportView):\n    headline = 'My fancy report'\n    tables = [] # So we can see the complete barebones report\n</code></pre> <p></p> <p>At this stage, our report isn't very useful. Before we get into building tables, we need to familiarize ourselves with the basic building blocks.</p>"},{"location":"reports/building-reports/#creating-our-first-table","title":"Creating our first table","text":"<p>Let's say we want to create a two variable truth table. A table with two columns for the two variables would look like this:</p> Table instantiation<pre><code>ReportTable(('A', 'B'), heading=\"Two variable truth table\")\n</code></pre> <p>At this point, we could add this table instance into the table list in our report, but we would only get the table header (the first row), because we haven't actually added any data to it yet.</p> <p>We have two options when it comes to adding rows, an implicit function (<code>add_row_impl()</code>) and an explicit function (<code>add_row_expl()</code>). If not enough cells in a row is provided to match the number of columns, empty cells are rendered in instead.</p> <code>add_row_impl()</code> <p>This function takes in an arbitrary number of cells.</p> <code>add_row_expl()</code> <p>This function expects an instance of <code>ReportTableRow</code>.</p> <p><pre><code>class MyReportView(ReportView):\n    headline = 'My fancy report'\n\n    def get_tables(self):\n        truth_table = ReportTable(('A', 'B'), heading=\"Two variable truth table\")\n\n        truth_table.add_row_impl(ReportTableCell('0'), ReportTableCell('0'))\n        truth_table.add_row_impl(ReportTableCell('1'), ReportTableCell('0'))\n        truth_table.add_row_impl(ReportTableCell('0'), ReportTableCell('1'))\n        truth_table.add_row_impl(ReportTableCell('1'), ReportTableCell('1'))\n\n        return [truth_table]\n</code></pre> </p>"},{"location":"reports/building-reports/#production-example-1","title":"Production example 1","text":"<p>So that we can understand the system more, let's make reports that are already built and in production. This report will consist of a singular table where each row represents a single 'jednotka' and each column an important property of each instance.</p> <p>The columns required are the following:</p> <ul> <li>\u010c\u00edslo jednotky</li> <li>Typ</li> <li>Kontakty</li> <li>Variabiln\u00ed symbol jednotky</li> <li>Patro</li> <li>Plocha (v m<sup>2</sup>)</li> <li>Pod\u00edl</li> <li>Po\u010det osob</li> <li>Voliteln\u00e9 slu\u017eby</li> <li>P\u0159edpis z\u00e1loh</li> </ul> <pre><code>class SestavaByty(DumReportView): # (1)!\n    title = 'Sestava jednotky' # (2)!\n\n    def get_tables(self):\n        table = ReportTable((\n            'Jednotka&lt;br&gt;(\u010d\u00edslo)', 'Typ', 'Kontakty', 'Jednotka&lt;br&gt;(VS)', 'Patro', 'Plocha', 'Pod\u00edl', 'Po\u010det osob',\n            'Voliteln\u00e9 slu\u017eby', 'P\u0159edpis z\u00e1loh'\n        ), 'Kontroln\u00ed sestava jednotky') # (3)!\n\n        for jednotka in Byty.objects.vyber_dum(self.get_referral_dum()): # (4)!\n            table.add_row_impl(\n                ReportTableCell(jednotka.cislo),\n                ChoiceCell(jednotka.typ_jednotky, TypyJednotek), # (5)!\n                ReportTableCell([\n                    (\n                        f'{contact.kontakt}*' if isinstance(jednotka.seznam_kontaktu_report, VlastniciQuerySet)\n                        else contact.kontakt\n                    )\n                    for contact in jednotka.seznam_kontaktu_report\n                ]), # (6)!\n                ReportTableCell(jednotka.variabilni),\n                ReportTableCell(jednotka.patro),\n                ReportTableCell(f'{jednotka.rozloha}m&lt;sup&gt;2&lt;/sup&gt;'),\n                ReportTableCell(jednotka.velikost_podilu_zlomek),\n                ReportTableCell(jednotka.pocet_osob),\n                ReportTableCell(jednotka.pocet_volitelnych_sluzeb),\n                CurrencyCell(secti_platne_definice_zaloh_byt(jednotka))\n            )\n\n        return [table]\n</code></pre> <ol> <li>We're using the extended version of the base <code>ReportView</code>, because it has convenient features tailored to reports that have anything to do with 'Domy' of 'Byty'.</li> <li>Setting the page title to 'Sestava jednotky'.</li> <li>Report table instantiation. Passing in a tuple of column names and a table heading.</li> <li>Iterating over all the jednotky and adding a row to the table for each one.</li> <li>Property <code>jednotka.typ_jednotky</code> returns either 'A' or 'B'. The <code>TypyJednotek</code> is a mapping of these two values to their corresponding names. Instead of using the generic <code>ReportTableCell</code> and an if statement, we use the <code>ChoiceCell</code> that is designed for this purpose.</li> <li>The <code>seznam_kontaktu_report</code> property returns either a <code>VlastniciQuerySet</code> or <code>NajemniciQuerySet</code>. A contact that is a 'Vlastnik' needs to have a asterisk attached.</li> </ol> <p></p>"},{"location":"reports/building-reports/#production-example-2","title":"Production example 2","text":"<p>Let's now take a much more complex report. In this example, we will look at the 'Z\u00e1v\u011bre\u010dn\u00e9 vy\u00fa\u010dtov\u00e1n\u00ed slu\u017eeb'. </p> <p>It consists of an extra header content, a custom table renderer and three tables.</p> <p>The individual tables are in their separate classes as not to introduce too much clutter in the <code>views.py</code> files.</p> <pre><code>class SestavaZaverecneVyuctovaniSluzeb(DumReportView):\n    title = 'Z\u00e1v\u011bre\u010dn\u00e9 vy\u00fa\u010dtov\u00e1n\u00ed slu\u017eeb'\n    extra_header = TemplateContent(\n        'snippets/report_kontrolni_sestava_period_extra_header.html',\n        sestava='p\u0159ehled z\u00e1v\u011bre\u010dn\u00e9ho vy\u00fa\u010dtov\u00e1n\u00ed slu\u017eeb'\n    ) # (1)!\n    report_renderer = 'snippets/zaverecne_vyuctovani_sluzeb_report_renderer.html' # (2)!\n\n    def get_tables(self):\n        tables = []\n\n        # Tabulka I.\n        predpisy_zaloh_table = PrehledZaverecnehoVyuctovaniSluzeb(self.referral_dum, self.vybrany_rok)\n\n        # Tabulka II.\n        vyuctovani_sluzeb_table = DetailniVyuctovaniSluzeb(self.referral_dum, self.vybrany_rok)\n\n        # Tabulka III.\n        summary_table = KonecneSouctySluzeb(self.referral_dum, self.vybrany_rok, predpisy_zaloh_table.jednotky_totals)\n\n        tables.extend([predpisy_zaloh_table, vyuctovani_sluzeb_table, summary_table])\n        return tables\n</code></pre> <ol> <li>A common header extracted into a template extra content. Discussed in a following section.</li> <li>A custom renderer used to insert a print-only page break after every table. The renderer code itself can be seen in a codeblock below.</li> </ol> <p>The custom renderer, as mentioned, adds a print-only page break after every table, so that the printed report has each paper dedicated to every table.</p> snippets/zaverecne_vyuctovani_sluzeb_report_renderer.html<pre><code>{% extends 'snippets/report_renderer.html' %}\n{% block table_after %}\n    {{ block.super }}\n    {% if not forloop.last %}\n        &lt;div class=\"print-page-break\"&gt;&lt;/div&gt;\n    {% endif %}\n{% endblock %}\n</code></pre>"},{"location":"reports/building-reports/#extra-content","title":"Extra content","text":"<p>The view takes advantage of the <code>extra_header</code> property. The <code>TemplateContent</code> is used with the template <code>report_kontrolni_sestava_period_extra_header.html</code>.</p> <p>The report header is captured on the image below. </p> <p>The report title (labeled with a 1) is handled by the <code>DumReportView</code>. It is aware of what 'Dum' we are dealing with and using that information it dynamically creates the report title.</p> <p>The extra content template gets passed a <code>sestava</code> parameter (used in the title labeled with a 2) and already has access to the year of the report (labeled with a 3) so using this extra content saves on repeating code.</p> <p></p>"},{"location":"reports/building-reports/#individual-tables","title":"Individual tables","text":"<p>In this section, the source code for the three tables is shown and described. Only the main construction part of the class is shown, because there is no need to show setting the columns, titles, etc.</p> PrehledZaverecnehoVyuctovaniSluzeb<pre><code>for jednotka in self.aktivni_jednotky(date(self._year, 12, 31)):\n    sluzby = []\n    for category in self._categories: # (1)!\n        amount = get_kategorie_zalohy_castka(jednotka, category, self._year)\n        sluzby.append(CurrencyCell(amount))\n        self.totals[list(self._categories).index(category)] += amount if amount is not None else 0\n\n    self.add_row_impl(\n        ReportTableCell(jednotka.variabilni),\n        ReportTableCell(jednotka.primarni_kontakt),\n        *sluzby # (2)!\n    )\n\nself.add_row_expl(ReportTableRow.total_table_sum_row(\n    EmptyCell(), *[CurrencyCell.sum_cell(total) for total in self.totals]\n)) # (3)!\n</code></pre> <ol> <li>Compiling the categories.</li> <li>Adding the cells. Every 'jednotka' may have a different amount of cells so there might be empty cells in some columns.</li> <li>Adding a final summation row. Displays the totals of all the rows summed up.</li> </ol> <p></p> DetailniVyuctovaniSluzeb<pre><code>totals = {index: 0 for index, sluzba in enumerate(self.sluzby_domu_mimo_fo)} # (1)!\n\nfor jednotka in self.aktivni_jednotky(date(self.year, 12, 31)):\n    def handle_sluzba(sluzba, index):\n        suma = self.soucet_vyuctovani_sluzby_pro_jednotku(jednotka, sluzba, self.year)\n        totals[index] += suma\n        return suma if suma != 0 else None\n\n    self.add_row_impl(\n        ReportTableCell(jednotka.variabilni),\n        *[\n            CurrencyCell(handle_sluzba(sluzba_definice, index))\n            for index, sluzba_definice in enumerate(self.sluzby_domu_mimo_fo)\n        ] # (2)!\n    )\nself.add_row_expl(ReportTableRow.total_table_sum_row(\n    *(CurrencyCell.sum_cell(total) for total in totals.values())\n)) # (3)!\n</code></pre> <ol> <li>A dictionary to keep track of totals of 'slu\u017eby' to later display in the last summation row.</li> <li>The table has a variable amount of columns depending on what sluzby the 'Dum' has.</li> <li>Adding a final summation row. Displays the totals of all the rows summed up.</li> </ol> <p></p> KonecneSouctySluzeb<pre><code>predpisy_total = 0\nplatby_total = 0\ncelkem_total = 0\nfor jednotka in self.aktivni_jednotky(date(self.year, 12, 31)):\n    sluzby_bez_fo = self.soucet_vyuctovani_sluzeb_pro_jednotku(\n        jednotka, self.sluzby_domy_mimo_fo(), self.year\n    )\n\n    predpisy = sluzby_bez_fo + self.jednotky_totals[jednotka.variabilni]\n    platby = self.jednotka_zaplaceno_na_zalohach(jednotka, self.year)\n    celkem = round(platby - predpisy)\n\n    self.add_row_impl(\n        ReportTableCell(jednotka.variabilni),\n        CurrencyCell(predpisy),\n        CurrencyCell(platby),\n        CurrencyCell(celkem)\n    )\n    predpisy_total += predpisy\n    platby_total += platby\n    celkem_total += celkem\n\nself.add_row_expl(ReportTableRow.total_table_sum_row(\n    CurrencyCell.sum_cell(predpisy_total),\n    CurrencyCell.sum_cell(platby_total),\n    CurrencyCell.sum_cell(celkem_total)\n)) # (1)!\n</code></pre> <ol> <li>Adding a final summation row. Displays the totals of all the rows summed up.</li> </ol> <p></p> <p>The final report looks like this:</p> <p></p>"},{"location":"reports/report-view/","title":"Report View","text":"<p>At the heart of every report lies the <code>ReportView</code> class. At the high level, it facilitates putting the whole report together (so not just inidividual tables). It defines how everything is layed out, what the page title and headline are. It also takes care of extra content. Holds a reference to the table renderer template so it can indirectly affect what individual tables look like.</p> <p>The class has the following definition (only properties are show, function implementations are irrelevant):</p> ReportView class properties<pre><code>class ReportView(LoginRequiredMixin,\n                 GetPostParametersMixin,\n                 TemplateView):\n    table_renderer: str = 'snippets/report_table_renderer.html'\n    template_name: str = 'asbd_report_base_template.html'\n    title: str = 'Sestava'\n    tables = []\n    headline = 'Nepojmenovan\u00e1 sestava'\n\n    extra_header: ExtraContent = None\n    extra_footer: ExtraContent = None\n</code></pre> <p>In this state, the view will not throw any exceptions complaining that it's missing properties. The report itself generated by this class will be solely a heading with the default dividers and a footer containing a singature.</p> <p>A minimal configuration:</p> <pre><code>class MyReport(ReportView):\n    pass\n</code></pre> <p></p> <p>It holds the following properties:</p> <code>title</code> <p>The title of the report page.</p> <p>Defaults to 'Sestava'.</p> <code>headline</code> <p>The headline of the report page.</p> <p>Defaults to 'Nepojmenovan\u00e1 sestava'</p> <p></p> <code>tables</code> <p>A list of <code>ReportTable</code> instances.</p> <p>Each report view also needs a template and a table renderer (also just a template).</p> <code>template_name</code> <p>Because reports are a highly specialized feature (mainly CSS-wise), we can't use the standard base template. Instead, a dedicated report base template is used.</p> <p>Takes care of the headline, extra content, dividers, etc. and passes the list of tables to the template which renders them using a table renderer.</p> <pre><code>&lt;!-- &lt;html&gt; &lt;head&gt; etc. --&gt;\n&lt;body&gt;\n{% block header %}\n    {% block headline %}\n        {% if report_headline %}\n            &lt;div class=\"headline\"&gt;\n                &lt;p&gt;{{ report_headline }}&lt;/p&gt;\n            &lt;/div&gt;\n        {% endif %}\n    {% endblock %}\n    {% resolve_extra_content extra_header %}\n{% endblock %}\n{% block content-header_divider %}\n    &lt;hr&gt;\n{% endblock %}\n{% block main_content_data %}\n    &lt;br&gt;\n    {% for table in tables %}\n        {% include table_renderer with table=table %}\n    {% endfor %}\n{% endblock %}\n{% block content-footer_divider %}\n    &lt;hr&gt;\n{% endblock %}\n{% block footer %}\n    {% resolve_extra_content extra_footer %}\n    {% block footer_signature %}\n        {% include 'snippets/report_footer_signature.html' %}\n    {% endblock %}\n{% endblock %}\n&lt;/body&gt;\n</code></pre> <p>Multiple blocks (injection points) are available for customization:</p> <code>header</code> <p>Renders the headline and extra content.</p> <code>content-header_divider</code> <p>Divider between <code>header</code> and <code>main_content_data</code>.</p> <p>Defaults to '&lt;hr&gt;'.</p> <code>main_content_data</code> <p>Includes the renderer template.</p> <code>content-footer_divider</code> <p>Divider between <code>main_content_data</code> and <code>footer</code>.</p> <p>Defaults to '&lt;hr&gt;'.</p> <code>footer</code> <p>Renders the extra content and a signature.</p> <p>The footer signature snippet looks like this:</p> snippets/report_footer_signature.html<pre><code>{% load user_display %}\n&lt;footer&gt;\n    Sestavu vytiskl: &lt;b&gt;{{ user|user_display }}&lt;/b&gt;, datum tisku: &lt;i&gt;{% now 'DATETIME_FORMAT' %}&lt;/i&gt;\n&lt;/footer&gt;\n</code></pre> <p>Defaults to 'asbd_report_base_template.html'.</p> <code>table_renderer</code> <p>As previously mentioned, it's another template. It is responsible for rendering each table.</p> <p>Can also be extended to accomodate special tables.</p> <p>Defaults to 'report_table_renderer.html'.</p> report_table_renderer.html<pre><code>{% load conditionals %}\n{% load reports %}\n{% if forloop.first %}\n    {% block table_before_first %}{% endblock %}\n{% elif forloop.last %}\n    {% block table_before_last %}{% endblock %}\n{% else %}\n    {% block table_before_other %}{% endblock %}\n{% endif %}\n{% block table_before %}\n    {% if table.heading %}\n        &lt;h4 class=\"table-heading\"&gt;{{ table.heading }}&lt;/h4&gt;\n    {% endif %}\n    &lt;p class=\"table-info\"&gt;{{ table.info|if_present }}&lt;/p&gt;\n{% endblock %}\n{% block render %}{% render_report_table table %}{% endblock %}\n{% block table_after %}\n    &lt;br&gt;\n{% endblock %}\n{% if forloop.first %}\n    {% block table_after_first %}{% endblock %}\n{% elif forloop.last %}\n    {% block table_after_last %}{% endblock %}\n{% else %}\n    {% block table_after_other %}{% endblock %}\n{% endif %}\n</code></pre> <p>Multiple blocks (injection points) are available for customization:</p> <p><code>table_before_first</code> - Content to insert before the first table</p> <p><code>table_before_last</code> - Content to insert before the last table</p> <p><code>table_before_other</code> - Content to insert before any other table</p> <code>table_before</code> <p>Content to insert before every table.</p> <p>Renders the optional heading and info by default.</p> <p><code>render</code> - Holds the tag call (<code>{% render_report_table table %}</code>) to render the table.</p> <p><code>table_after</code> - Content to insert after every table</p> <p><code>table_after_first</code> - Content to insert after the first table</p> <p><code>table_after_last</code> - Content to insert after the last table</p> <p><code>table_after_other</code> - Content to insert after any other table</p>"},{"location":"reports/report-view/#extending-the-report-template","title":"Extending the report template","text":"<p>A good example of a modified report template is the <code>zaverecne_vyuctovani_rozklad_report_template.html</code>. We only needed to render the tables and nothing else.</p> zaverecne_vyuctovani_rozklad_report_template.html<pre><code>{% extends 'asbd_report_base_template.html' %}\n{% block header %}{% endblock %}\n{% block content-header_divider %}{% endblock %}\n{% block content-footer_divider %}{% endblock %}\n{% block footer %}{% endblock %}\n</code></pre>"},{"location":"reports/report-view/#extending-the-table-renderer","title":"Extending the table renderer","text":"<p>The purpose of the <code>zaverecne_vyuctovani_sluzeb_report_table_renderer.html</code> is to insert a print only page break after every table (except the last one, because the printer would just spit out an empty paper).</p> <p>In this case, we couldn't have used the <code>table_after_other</code> block because the page break wouldn't be inserted after the first table. For that reason, we had to use the broader <code>table_after</code> block and manually check if the table is not the last one.</p> zaverecne_vyuctovani_sluzeb_report_table_renderer.html<pre><code>{% extends 'snippets/report_table_renderer.html' %}\n{% block table_after %}\n    {{ block.super }}\n    {% if not forloop.last %}\n        &lt;div class=\"print-page-break\"&gt;&lt;/div&gt;\n    {% endif %}\n{% endblock %}\n</code></pre>"},{"location":"reports/report-view/#extending-the-base-view","title":"Extending the base view","text":"<p>The base <code>ReportView</code> may be extended to abstract out common functionality. The most common example is the <code>DumReportView</code> class, which is specifically tailored for reports that are in some way tied to a single <code>Dum</code> or <code>Byt</code>.</p> <p>As far as the report system goes, the <code>DumReportView</code> just automates the process of setting a headline.</p> The headline logic in the DumReportView class<pre><code>def get_report_headline(self):\n    if self.referral_dum:\n        return f'D\u016fm: {self.referral_dum.display_altername_or_street_name}'\n    elif self.referral_byt:\n        return f'Jednotka: {self.referral_byt.name_variabilni_symbol}'\n    else:\n        return 'N\u00e1zev nen\u00ed k dispozici'\n</code></pre>"},{"location":"reports/report-view/#extra-content","title":"Extra content","text":"<p>Every report can have extra content in the header and footer. This is what the <code>extra_header</code> and <code>extra_footer</code> properties are for.</p> <p>The <code>ExtraContent</code> base class has a singular function - <code>render()</code>. It is every extending class's responsibility to implement it.</p>"},{"location":"reports/report-view/#templatecontent","title":"TemplateContent","text":"<p>The <code>TemplateContent</code> is used to include one or more templates in the report.</p> Example 1: Assigning the property directly<pre><code>class SestavaPredpisyPlatbyMesicni(DumReportView):\n    title = 'M\u011bs\u00ed\u010dn\u00ed rekapitulace p\u0159edpis\u016f a plateb'\n    extra_header = TemplateContent('snippets/report_kontrolni_sestava_period_extra_header.html',\n                                   sestava='m\u011bs\u00ed\u010dn\u00ed rekapitulace p\u0159edpis\u016f a plateb (kumulovan\u011b)')\n</code></pre> Example 2: Using a function - dynamic context<pre><code>def get_extra_header_content(self):\n    return TemplateContent(\n        'snippets/report_kontrolni_sestava_period_extra_header.html',\n        sestava=f'seznam ode\u010dt\u016f m\u011b\u0159idel pro slu\u017ebu {self.sluzba}'\n    )\n</code></pre>"},{"location":"reports/report-view/#stringcontent","title":"StringContent","text":"<p>If we simply want to add text, the <code>StringContent</code> is perfect tool for the job. By default all lines suppplied are concatenated and separated by a newline character (\\n), which is automatically translated to a &lt;br&gt; tag. </p> <p>The rendered string is not marked safe by default, so a <code>safe</code> parameter needs to be set to <code>True</code>.</p> <pre><code>class MyReport(ReportView):\n    extra_header = StringContent(\n        'This is a string content', \n        'This is a second line',\n        safe=True\n    )\n</code></pre>"},{"location":"styleable-components/","title":"Styleable components","text":"<p>When it comes to generating HTML in code, it is often necessary to apply CSS to the generated elements. For this reason, the shared library provides the <code>StyleModifier</code> class.</p> <p>The <code>StyleModifier</code> class encapsulates an arbitrary number of CSS classes and also individual CSS properties. The <code>get_attributes()</code> function can then be used to generate the HTML attributes for the element.</p> <p>Generated attributes</p> <pre><code>StyleModifier(('class1', 'class2'), {'color':'blue'}).get_attributes()\n</code></pre> <p>If this style modifier were to be applied to a <code>div</code> element, the resulting HTML would look like this:</p> <pre><code>&lt;div class=\"class1 class2\" style=\"color: blue;\"&gt;&lt;/div&gt;\n</code></pre> <p>The <code>get_attributes()</code> function pretty much just concatenates the classes and properties into a string (as shown in the code block below). So, if for some reason you need to get the classes and properties separately, you can use the <code>get_class_attribute()</code> and <code>get_style_attribute()</code> functions. </p> Implementation of get_attributes()<pre><code>def get_attributes(self):\n    return f'{self.get_class_attribute()}{self.get_style_attribute()}'\n</code></pre> <p>The <code>StyleModifier</code> also has an extension functionality, which allows for combination of different style modifier objects.</p> Combining style modifiers<pre><code>StyleModifier(styles={'text-align': 'right'}).extend(StyleModifier(('class1',)))\n</code></pre>"},{"location":"styleable-components/#an-example","title":"An example","text":"View<pre><code>def get_context_data(self):\n    return {\n        'style': StyleModifier(('class1', 'class2'), {'color':'blue'}),\n        **super().get_context_data()\n    }\n</code></pre> Template<pre><code>&lt;div {{ style.get_class_attribute() }} {{ style.get_style_attribute() }}&gt;Hello, world!&lt;/div&gt;\n&lt;!-- or use the convenient concatenation --&gt;\n&lt;div {{ style.get_attributes() }}&gt;Hello, world!&lt;/div&gt;\n</code></pre> Result<pre><code>&lt;div class=\"class1 class2\" style=\"color: blue;\"&gt;Hello, world!&lt;/div&gt;\n</code></pre>"},{"location":"view-menu/","title":"View menu","text":"<p>The view menu system on its own allows for a flexible way to define one or multiple menus for a given view directly from the view class.</p> <p>By default, the system can handle up to three menus according to their position on the screen - left, right, bottom. For every menu there has to exist a corresponding function that returns the menu object (an instance of <code>ViewMenu</code> class).</p> <p>The default function names are <code>get_left_menu()</code>, <code>get_right_menu()</code>, and <code>get_bottom_menu()</code>. The function names themselves can be changed by overriding the <code>menu_functions</code> dictionary (see below) in the <code>MenuMixin</code> class.</p> <pre><code>menu_functions = {\n    'menu_right': 'get_right_menu',\n    'menu_left': 'get_left_menu',\n    'menu_bottom': 'get_bottom_menu'\n}\n</code></pre> <p>The system looks for the previously mentioned functions in the view class and if they exist, their return values will be injected into the context under the corresponding key.</p> <p>An example</p> <p>A view that has a left and a right menu needs to implement the <code>get_left_menu()</code> and <code>get_right_menu()</code> functions. As a result, the context will contain the <code>menu_left</code> and <code>menu_right</code> keys with the corresponding menu objects that can be rendered in the template.</p> <p>Order of execution</p> <p>The <code>get_context_data()</code> function in <code>MenuMixin</code> gets executed prior to the one in the view itself.</p>"},{"location":"view-menu/#prerequisites","title":"Prerequisites","text":"<p>1) The view class must inherit from the <code>MenuMixin</code> class.</p> views.py<pre><code>class MyView(MenuMixin, View):\n    pass\n</code></pre> <p>2) For every menu, the view class must implement a corresponding function that returns the menu object.</p> <p>The function names are defined in the <code>menu_functions</code> dictionary in the <code>MenuMixin</code> class.</p> views.py<pre><code>class MyView(MenuMixin, View):\n    def get_left_menu(self):\n        return ViewMenu(\n            ...\n        )\n\n    def get_right_menu(self):\n        return ViewMenu(\n            ...\n        )\n</code></pre> <p>3) The menu object needs to be rendered in the template.</p> <p>A custom template tag is used to render the menus.</p> template.html<pre><code>{% if menu_left %}\n    {% render_menu menu_left %}\n{% endif %}\n\n{% if menu_right %}\n    {% render_menu menu_right %}\n{% endif %}\n</code></pre> <p>In case of ASBD, the <code>asbd_application_base_template.html</code> takes care of this and is also prepared to handle three menu positions.</p>"},{"location":"view-menu/#defaults","title":"Defaults","text":"<p>The <code>ViewMenu</code> object has several defaults.</p> <p>If no menu title is provided, it defaults to 'Dostupn\u00e9 akce...'</p> <p>Furthermore, a menu is rendered using a template. The default template to be used is the <code>default_view_menu_template.html</code>. Even though a specific template can be provided, it is not necessary in most cases.</p> snippets/default_view_menu_template.html<pre><code>{% load static %}\n\n&lt;!-- KONTEXTOVE ACTION MENU --&gt;\n&lt;div class='container-fluid mb-2'&gt;\n    &lt;!-- ZOBRAZ HLAVICKU --&gt;\n    &lt;div class='row mt-2 mb-2'&gt;\n        &lt;div class='col-12'&gt;\n            &lt;b&gt;{{ title }}&lt;/b&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;!-- LINK LIST --&gt;\n    {% for menu_item in menu_items %}\n        {% if menu_item.enabled %}\n            &lt;div class='row'&gt;\n                &lt;div class='col-12'&gt;\n                    {{ menu_item.html|safe }}\n                &lt;/div&gt;\n            &lt;/div&gt;\n        {% endif %}\n    {% endfor %}\n&lt;/div&gt;\n</code></pre> <p>Lastly, every <code>ViewMenu</code> has a default set of items that are prepended to the menu by default. In case we wanted to omit them, we can set the <code>default_items</code> parameter to <code>False</code>. The property itself is private so it cannot be overriden, just enabled or disabled.</p> <p>In the code block below we can see the <code>ViewMenu</code> default properties mentioned above.</p> ViewMenu<pre><code>class ViewMenu:\n    __default_menu_title = 'Dostupn\u00e9 akce...'\n    __default_menu_template = 'snippets/default_view_menu_template.html'\n    __default_items = [\n        LinkMenuItem('Krok zp\u011bt...', 'javascript:window.history.back()', reversible=False),\n        SpacerMenuItem()\n    ]\n</code></pre> <p>The simplest menu possible is simply just an instance of the <code>ViewMenu</code> class as shown below.</p> Empty menu<pre><code>def get_right_menu(self):\n    return ViewMenu()\n</code></pre> <p>The code above will result in an empty menu with the defaults applied as shown in the image below.</p> <p></p>"},{"location":"view-menu/examples/","title":"Examples","text":""},{"location":"view-menu/examples/#an-empty-menu","title":"An empty menu","text":"<p>As an example, let's take the <code>SluzbyDefiniceListingSearchView</code> view from the <code>sluzby</code> application. The class is stripped of anything that is not relevant to the menu system so as not to clutter the example.</p> sluzby/views.py<pre><code>class SluzbyDefiniceListingSearchView(LoginRequiredMixin,\n                                      DjangoPuzzleMixinWrapper,\n                                      GetPostParametersMixin,\n                                      UserConfiguredDefaultPaginationMixin,\n                                      HotkeyMixin,\n                                      ListView):\n    def get_right_menu(self):\n        return ViewMenu()\n\n    def get_left_menu(self):\n        return ViewMenu()\n\n    def get_bottom_menu(self):\n        return ViewMenu()\n</code></pre> <p>The view class has all three menu functions implemented. All of them simply return an empty <code>ViewMenu</code> object which is the bare minimum required to render a menu.</p> <p>Return value</p> <p>The function must return a <code>ViewMenu</code> object. If the function returns <code>None</code>, the menu will not be rendered.</p> <p></p> <p>As we can see, the view has all three menus rendered but they are empty (well, relatively empty - more on this in the Defaults section). </p>"},{"location":"view-menu/examples/#a-bit-more-capable-menu","title":"A bit more capable menu","text":"<p>Let's now focus on creating an actual useful menu (we will stick with the right menu only). We have the following requirements:</p> <p>1) A link to create a new object.</p> <p>2) A d\u016fm filter.</p> <ul> <li>If the <code>referraldumid</code> query parameter is present, hide the filter and add a link back to the listing without the filter.</li> </ul> sluzby/views.py<pre><code>def get_right_menu(self):\n    return ViewMenu(\n        # A link back to the listing without the filter conditionally displayed based on the value of the query parameter.\n        Conditional(\n            self.referral_dum,\n            VsechnySluzby(), # (1)!\n            SpacerMenuItem()\n        ), # (2)!\n        # A link to create a new object.\n        CreateLink('sluzby:sluzbydefinice-create', 'P\u0159idat novou slu\u017ebu', query_params=self.query_params),\n        # A spacer to separate the links.\n        SpacerMenuItem(),\n        # The filter.\n        DumFilters(self.request) # (3)!\n    )\n</code></pre> <ol> <li>The <code>VsechnySluzby</code> class is just a simple link that points to the listing view without any filters.</li> <li>The <code>Conditional</code> class is used to conditionally display the <code>VsechnySluzby</code> link. The <code>self.referral_dum</code> property has a value if the query parameter was set - thus the link is only displayed if the property is not <code>None</code>.</li> <li>The <code>DumFilters</code> class is just a wrapper around the <code>Filter</code> class that is specifically tailored for filtering by d\u016fm.</li> </ol> <p></p>"},{"location":"view-menu/menu-items/","title":"Menu items","text":"<p>The main building blocks of the menu system are the menu items. They are used to define the structure of the menu and can be nested to create complex menus.</p> <p>At the top of the hierarchy stands the <code>MenuItem</code> class. It is an abstract class that is not meant to be used directly. Instead, there are several concrete classes that inherit from it and provide actual functionality.</p> <p>A menu item can be enabled or disabled using the <code>enabled</code> property. By default, all menu items are enabled.</p> <p>The <code>MenuItem</code> class is a <code>StyleableComponent</code> and as such, using the <code>custom_css</code> property, it is possible to apply custom CSS classes to the menu item. More information about styling can be found on the Styling page.</p> <p>The following sections describe the concrete menu item classes.</p>"},{"location":"view-menu/menu-items/#linkmenuitem","title":"LinkMenuItem","text":"<p>Base class for all menu items that represent a simple link.</p> Basic usage<pre><code># A simple link\nLinkMenuItem('Link label', 'app:view')\n# Actual URL instead of a view name\nLinkMenuItem('Link label', '/some/url', reversible=False)\n</code></pre> <p>A set of path and query parameters can be passed to the link using the <code>path_params</code> and <code>query_params</code> arguments. Note that both arguments can be used at the same time.</p> Get and query parameters<pre><code># Given the URL definition 'view/&lt;int:pk&gt;/', the url will be 'view/1/'\nLinkMenuItem('Link label', 'app:view', path_params={'pk': '1'})\n# Results in /app/view/?param1=value1\nLinkMenuItem('Link label', 'app:view', query_params={'param1': 'value1'})\n</code></pre> <p>There are several classes that inherit from the <code>LinkMenuItem</code> class and provide additional functionality. The constructor signature is identical to the <code>LinkMenuItem</code> class.</p>"},{"location":"view-menu/menu-items/#successlink","title":"SuccessLink","text":"<p>Adds a success class to the link.</p> <pre><code>LinkMenuItem('Link label', 'app:view', custom_css=StyleModifier(('text-success',)))\n# vs\nSuccessLink('Link label', 'app:view')\n</code></pre>"},{"location":"view-menu/menu-items/#dangerlink","title":"DangerLink","text":"<p>Adds a danger class to the link.</p> <pre><code>LinkMenuItem('Link label', 'app:view', custom_css=StyleModifier(('text-danger',)))\n# vs\nDangerLink('Link label', 'app:view')\n</code></pre>"},{"location":"view-menu/menu-items/#listinglink","title":"ListingLink","text":"<p>Sets the label to 'V\u0161echny z\u00e1znamy' by default.</p> <pre><code>LinkMenuItem('V\u0161echny z\u00e1znamy', 'app:view',)\n# vs\nListingLink('app:view')\n</code></pre>"},{"location":"view-menu/menu-items/#createlink","title":"CreateLink","text":"<p>Sets the label to 'P\u0159idat nov\u00fd z\u00e1znam' by default.</p> <pre><code>LinkMenuItem('P\u0159idat nov\u00fd z\u00e1znam', 'app:view')\n# vs\nCreateLink('app:view')\n</code></pre>"},{"location":"view-menu/menu-items/#objectrelatedlink","title":"ObjectRelatedLink","text":"<p>Represents a link related to a single object, i.e. update the object, delete, view details, etc.</p> <p>It expects two arguments, <code>view_name</code> and <code>pk</code>. The <code>view_name</code> is the name of the view that the link points to and <code>pk</code> is the primary key of the object. The default label is 'Object link'.</p> <p>The raw use of the <code>ObjectRelatedLink</code> class on its own is not very helpful, so other subclasses are implemented.</p>"},{"location":"view-menu/menu-items/#updatelink","title":"UpdateLink","text":"<p>The label defaults to 'Upravit'.</p> <pre><code>LinkMenuItem('Upravit', 'app:view', query_params={'pk': self.object.pk})\n# vs\nUpdateLink('app:view', self.object.pk)\n</code></pre>"},{"location":"view-menu/menu-items/#deletelink","title":"DeleteLink","text":"<p>The label defaults to 'Vymazat' and a danger class is applied to the link.</p> <pre><code>LinkMenuItem('Vymazat', 'app:view', query_params={'pk': self.object.pk}, custom_css=StyleModifier(('text-danger',)))\n# vs\nDeleteLink('app:view', self.object.pk)\n</code></pre>"},{"location":"view-menu/menu-items/#spacermenuitem","title":"SpacerMenuItem","text":"<p>A simple menu item that renders a specific number of <code>&lt;br&gt;</code> tags (1 by default).</p> Basic usage<pre><code># A single spacer\nSpacerMenuItem()\n# Multiple spacers\nSpacerMenuItem(3)\n</code></pre>"},{"location":"view-menu/menu-items/#sectiontitle","title":"SectionTitle","text":"<p>Because we might want to split menus into different sections, the <code>SectionTitle</code> class is used to create a section title. It renders as a <code>&lt;b&gt;</code> tag.</p> <pre><code># Renders as &lt;b&gt;Section title&lt;/b&gt;\nSectionTitle('Section title')\n</code></pre>"},{"location":"view-menu/menu-items/#filters","title":"Filters","text":"<p>Filters usually come in handy in listing views. A filter is a list of links that simply add a query parameter to the URL and the server uses that to filter the results.</p> <p>The <code>Filter</code> class expects 3 arguments:</p> <code>request</code> <p>The request object. </p> <p>Mainly used to check if the filter has been applied, if so, the filter is not rendered.</p> <code>queryset</code> <p>The list of objects that can be used for filtering.</p> <code>query_parameter</code> <p>The name of the query parameter that will be added to the URL.</p> Basic usage<pre><code>Filter(request, queryset, 'filter')\n</code></pre> <p>Each object is rendered as a link. The actual link label is by default the string representation of the object. If the object is a model instance, the <code>__str__</code> method is used. It is possible to pass in a callable <code>display_name</code> argument.</p> Custom display name<pre><code>Filter(request, queryset, 'filter', display_name=lambda obj: obj.name)\n</code></pre> <p>The filter is rendered as a underscored heading and a list of links. The heading is by default 'Filtry zobrazen\u00ed' but can be changed with the <code>title</code> property.</p>"},{"location":"view-menu/menu-items/#extending-the-base-class","title":"Extending the base class","text":"DumFilter<pre><code>class DumFilter(Filters):\n    def __init__(self, request: HttpRequest, queryset: QuerySet = None, \n                 title: str = None, hide: bool = True, enabled: bool = True,\n                 custom_css: StyleModifier = None) -&gt; None:\n        super().__init__(request, queryset or Domy.objects.account_can_see(request.user), 'referraldumid',\n                         lambda dum: dum.display_altername_or_street_name, title, hide, enabled,\n                         custom_css)\n</code></pre> <p>This filter by default, if no queryset was provided, uses the <code>Domy</code> model and gets all the objects the current user has access to. </p> <p>The <code>query_parameter</code> is set to <code>referraldumid</code>.</p> <p>And lastly, the <code>display_name</code> is set to a lambda function that returns the <code>display_altername_or_street_name</code> property of the <code>Dum</code> model instance.</p> Usage<pre><code># The simplest way to use this filter\nDumFilter(request)\n# Using a custom queryset\nDumFilter(request, Domy.objects.all())\n</code></pre>"},{"location":"view-menu/menu-items/#conditionals","title":"Conditionals","text":"<p>As we discussed, every menu item has to possibility of being disabled. This behavior is controlled by the <code>enabled</code> property. If we have a bunch of menu items that need to be hidden given a common condition, adding that condition to each menu item is not very efficient. Instead, we can use the <code>Conditional</code> class.</p> <p>The <code>Conditional</code> class expects is just a wrapper for multiple menu items that is given a condition and based on its result, it enables or disables all the menu items it wraps around.</p> Basic usage<pre><code>ViewMenu(\n    VsechnyJednotky(),\n    SpacerMenuItem(enabled=self.referral_dum is not None),\n    CreateLink(\n        'byty:byty-create',\n        query_params={'referraldumid': referraldumid},\n        enabled=self.referral_dum is not None\n    ),\n    SpacerMenuItem(),\n    DumFilters(self.request, Domy.objects.account_can_see(self.request.user))\n)\n# vs\nViewMenu(\n    VsechnyJednotky(),\n    Conditional(\n        self.referral_dum is not None, # (1)!\n        SpacerMenuItem(),\n        CreateLink(\n            'byty:byty-create',\n            query_params={'referraldumid': referraldumid}\n        )\n    ),\n    SpacerMenuItem(),\n    DumFilters(self.request, Domy.objects.account_can_see(self.request.user))\n)\n</code></pre> <ol> <li>The condition that needs to be met for the menu items to be enabled.</li> </ol>"},{"location":"view-menu/menu-items/#otherwise","title":"Otherwise","text":"<p>The <code>Conditional</code> class also has a <code>otherwise()</code> function that takes in a list of menu items that will be enabled if the condition is not met.</p> <p>No conditionals in <code>otherwise()</code></p> <p>The <code>otherwise()</code> function does not take any conditionals. It is assumed that if the condition is not met, the menu items passed to the <code>otherwise()</code> function will be enabled.</p> <p>As an example, let's say if the <code>referraldumid</code> query parameter is present, we want to show a link to a listing view of objects related to that query parameter and a create view which we will pass the parameter to so it can be pre-filled. If the parameter is not present, we just want to show a generic create view.</p> Using otherwise<pre><code>Conditional(\n    self.referral_dum,\n    VsechnyKategorieFaktur(),\n    SpacerMenuItem(),\n    PridatKategoriiFaktur(query_params=self.query_params)\n).otherwise(\n    PridatKategoriiFaktur(),\n)\n</code></pre>"},{"location":"view-menu/menu-items/#collapsibles","title":"Collapsibles","text":"<p>The menu system has support for collapsible sections. It is a way to group menu items together and hide them behind a toggle button.</p>"},{"location":"view-menu/menu-items/#toggle-buttonlink","title":"Toggle button/link","text":"<pre><code>toggle = CollapsibleSectionTitle('Sestavy', 'sestavyCollapse') # (1)!\n# or\ntoggle = CollapsibleSectionToggle('Sestavy', 'sestavyCollapse') # (2)!\n</code></pre> <ol> <li>The title of the collapsible section.</li> <li>Just a simple link that toggles the collapsible section.</li> </ol>"},{"location":"view-menu/menu-items/#collapsiblesection","title":"CollapsibleSection","text":"<pre><code>section = CollapsibleSection(\n    'sestavyCollapse', # (1)!\n    LinkMenuItem('Sestava jednotky', 'byty:sestava-byty', query_params=query),\n    LinkMenuItem('Sestava slu\u017eby', 'sluzby:sestava-sluzby', query_params=query),\n    LinkMenuItem('Sestava kategorie z\u00e1lohy', 'sluzby:sestava-kategorie-zaloh',\n                 query_params=query),\n    LinkMenuItem('Sestava definice z\u00e1loh', 'sluzby:sestava-zalohy-definice',\n                 query_params=query),\n    LinkMenuItem('Sestava platby z\u00e1loh', 'sluzby:sestava-zalohy-platby',\n                 query_params=query),\n    LinkMenuItem('Sestava ode\u010dty', 'sluzby:sestava-odecty', query_params=query),\n    LinkMenuItem('Sestava faktury', 'sluzby:sestava-faktury', query_params=query),\n    LinkMenuItem('Sestava vlastn\u00edci', 'byty:sestava-byty-vlastnici', query_params=query),\n    LinkMenuItem('Sestava n\u00e1jemn\u00edci', 'byty:sestava-byty-najemnici', query_params=query),\n)\n</code></pre> <ol> <li>The <code>collapse_id</code>. Must match with the <code>collapse_id</code> of the toggle button.</li> </ol>"},{"location":"view-menu/menu-items/#creating-a-custom-menu-item","title":"Creating a custom menu item","text":"<p>The <code>MenuItem</code> class has an empty function called <code>html</code> that needs to be implemented in the concrete classes. The function is responsible for rendering the menu item.</p> <p>As an example, let's take the spacer menu item. It is a simple menu item that renders a number of <code>&lt;br&gt;</code> tags.</p> The spacer menu item implementation<pre><code>class SpacerMenuItem(MenuItem):\n    def __init__(self, units: int = 1, enabled: bool = True) -&gt; None:\n        super().__init__(enabled)\n        self.units = units\n\n    def html(self):\n        return '&lt;br&gt;' * self.units\n</code></pre> <p>Because the <code>extra_css</code> argument in the <code>MenuItem</code> class default to <code>None</code>, we only need to pass in the <code>enabled</code> parameter if we wish to be able to control that from the <code>SpacerMenuItem</code> class. If our custom menu item for whatever reason was never going to be disabled, we could omit the <code>enabled</code> parameter altogether and just call the parent constructor with <code>super().__init__()</code>.</p>"}]}